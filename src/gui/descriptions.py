from ..utils import *

DESC = {
    "Check": {
        True: """When checking this option you'll be able to run a specific test from the chosen type.
The standard procedures are not run.""",
        False: """By leaving this option unchecked, the standard test procedures are run.
These procedures are defined by the chosen type."""
    },
    "Test": {
        BSI_TESTS.disjointness: """Disjointness test.
This test requires at least 3 145 728 bits.""",
        BSI_TESTS.monobit: """Monobit test.
This test requires at least 20 000 bits.""",
        BSI_TESTS.poker: """Poker test.
This test requires at least 20 000 bits.""",
        BSI_TESTS.runs: """Runs test.
This test requires at least 20 000 bits.""",
        BSI_TESTS.longrun: """Long run test.
This test requires at least 20 000 bits.""",
        BSI_TESTS.autocorrelation: """Auto-correlation test.
This test requires at least 20 000 bits.""",
        BSI_TESTS.uniform_distribution: """Uniform distribution test.
This test requires at least 200 000 bits.""",
        BSI_TESTS.homogeneity: """Homogeneity test.
This test requires at least 200 000 bits.""",
        BSI_TESTS.entropy: """Entropy test.
This test requires at least 2 068 480 bits.""",
        NIST_TESTS.monobit: """Monobit test.
This test requires at least 100 bits.""",
        NIST_TESTS.frequency_block: """Frequency test within a block.
This test requires at least 100 bits.""",
        NIST_TESTS.runs: """Runs test.
This test requires at least 100 bits.""",
        NIST_TESTS.longestrun: """Test for the longest run of ones in a block.
This test requires at least 128 bits.""",
        NIST_TESTS.non_overlapping_template: """Non-overlapping template matching test.
This test requires at least 100 bits.""",
        NIST_TESTS.overlapping_template: """Overlapping template matching test.
This test requires at least 1 000 000 bits.""",
        NIST_TESTS.cusum: """Cumulative sums test.
This test requires at least 100 bits.""",
        NIST_TESTS.binary_matrix_rank: """Binary matrix rank test.
This test requires at least 38 912 bits.""",
        NIST_TESTS.linear_complexity: """Linear complexity test.
This test requires at least 1 000 000 bits.""",
        NIST_TESTS.serial: """Serial test.
This test requires at least 100 bits.""",
        NIST_TESTS.approximate_entropy: """Approximate entropy test.
This test requires at least 100 bits.""",
        NIST_TESTS.random_excursion: """Random excursion test.
This test requires at least 1 000 000 bits.""",
        NIST_TESTS.random_excursion_variant: """Random excursion variant test.
This test requires at least 1 000 000 bits.""",
        NIST_TESTS.maurer: """Maurer's universal statistical test.
This test requires at least 387 840 bits.""",
        NIST_TESTS.spectral: """Discret Fourier transform (spectral) test.
This test requires at least 1 000 bits.""",
    },
    "PRNG": {
        PRNGS.External: """An external PRNG.
This option allows you to test a PRNG without direct access to it.
Random data must be provided by a separate file, in one of the supported formats.""",
        PRNGS.RANDU: """The famously broken RANDU PRNG from IBM.
This PRNG can be used to see an example of how the different tests behave on the output of a bad PRNG.
Random data will automatically be generated by the program.""",
        PRNGS.PyRandom: """Python's random module.
Python uses the Mersenne Twister as the core generator.
The Mersenne Twister is one of the most extensively tested random number generators in existence.
However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.
Random data will automatically be generated by the program.""",
        PRNGS.DevURandom: """Linux's '/dev/urandom.
Since Linux kernel version 4.8, the kernel's /dev/urandom was switched over to a ChaCha20-based cryptographic pseudorandom number generator (CPRNG).
Since Linux kernel version 5.6 /dev/random implementation was also switched to the ChaCha20-based CPRNG, which blocks only when the CPRNG hasn't initialized.
Once initialized, /dev/random and /dev/urandom behave the same.
Random data will automatically be read by the program."""
    },
    "Type": {
        TEST_TYPES.BSI: """Tests defined by the BSI.
See the README for references to the official description of the tests and procedures.
At least 5140000 bits are needed to run the procedures.""",
        TEST_TYPES.NIST: """Tests defined by the NIST.
See the README for references to the official description of the tests and procedures.
At least XXX bits are needed to run the procedures."""
    },
    "Parser": {
        PARSERS.Raw: """Raw data format.
The content of the file is interpreted as raw binary data.
This is not the same as the binary format ('01...10').
Such a conversion will always succeed but won't produce the expected outcome if your input file has the wrong format.
Example :
'A\\x89' -> '0100000110001001' (good input format)
'0110' -> '00110000001100010011000100110000' (wrong input format)""",
        PARSERS.Hex: """Hexadecimal format.
The content of the file is interpreted as the ASCII representation of hexadecimal data.
The file must contain only hexadecimal characters except for spaces, newline and tabulations.
Such a conversion may succeed but won't produce the expected outcome if your input file has the wrong format.
Example :
'4189' -> '0100000110001001' (good input format)
'0110' -> '0000000100010000' (wrong input format)
""",
        PARSERS.Binary: """Binary format.
The content of the file is interpreted as the ASCII representation of binary data.
The file must contain only 0s and 1s except for spaces, newline and tabulations.
Example :
'0110' -> '0110' (good input format)""",
    }
}
